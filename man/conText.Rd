% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/conText.R
\name{conText}
\alias{conText}
\title{Embedding regression}
\usage{
conText(
  formula,
  data,
  text_var = "text",
  pre_trained,
  transform = TRUE,
  transform_matrix,
  bootstrap = TRUE,
  num_bootstraps = 20,
  stratify_by = NULL,
  permute = TRUE,
  num_permutations = 100,
  getcontexts = TRUE,
  window = 6,
  valuetype = "fixed",
  case_insensitive = TRUE,
  hard_cut = FALSE,
  verbose = TRUE
)
}
\arguments{
\item{formula}{(from lm function) an object of class "formula" (or one that can be coerced to that class): a
symbolic description of the model to be fitted.}

\item{data}{a data.frame containing the variables in the model}

\item{text_var}{chr - name of variable with the text from which context will be extracted}

\item{pre_trained}{a V x D matrix of numeric values - pretrained embeddings with V = size of vocabulary and D = embedding dimensions}

\item{transform}{logiacl - if TRUE (default), apply ALC transformation, if FALSE simply average context embeddings}

\item{transform_matrix}{square numeric matrix corresponding to the transformation matrix}

\item{bootstrap}{logical - if TRUE, bootstrap regression - required to get standard errors for normed coefficients}

\item{num_bootstraps}{numeric - number of bootstraps to use}

\item{stratify_by}{chr vector - specifying variables to stratify by when bootstrapping}

\item{permute}{logical - if TRUE, compute empirical p-values using permutation test}

\item{num_permutations}{numeric - number of permutations to use}

\item{getcontexts}{logical - if TRUE, apply get_context function to get context around target word (Y in formula)}

\item{window}{integer - defines the size of a context (words around the target)
See conText documentation for get_context.}

\item{valuetype}{the type of pattern matching: "glob" for "glob"-style wildcard expressions;
"regex" for regular expressions; or "fixed" for exact matching.
See quanteda's documentation for the kwic function.
See conText documentation for get_context.}

\item{case_insensitive}{logical - if TRUE, ignore case when matching the target.
if valuetype = 'fixed' then this argument is ignored
See quanteda's documentation for the kwic function.
See conText documentation for get_context.}

\item{hard_cut}{logical - if TRUE then the text must have window x 2 tokens,
if FALSE it can have window x 2 or fewer (e.g. if a doc begins with a target word,
then text will have window tokens rather than window x 2).
See conText documentation for get_context.}

\item{verbose}{print comments}
}
\value{
list with two elements, \code{betas} = list of beta_cofficients (D dimensional vectors);
\code{normed_betas} = tibble with the norm of the non-intercept coefficients, std.errors (given boostrap), empirical pvalue (given permute)
}
\description{
Estimate an embedding regression model
}
\examples{
library(conText)
library(dplyr)

# load data
corpus <- sample_corpus
pre_trained <- sample_glove
transform_matrix <- khodakA

# add party indicator variable
corpus <- corpus \%>\% mutate(Republican = if_else(party == 'R', 1, 0))

# run conText
model1 <- conText(formula = immigration ~ Republican,
                  data = corpus,
                  text_var = 'speech',
                  pre_trained = pre_trained,
                  transform = TRUE, transform_matrix = transform_matrix,
                  bootstrap = TRUE, num_bootstraps = 10,
                  stratify_by = 'Republican',
                  permute = TRUE, num_permutations = 100,
                  getcontexts = TRUE, window = 6, valuetype = "fixed",
                  case_insensitive = FALSE,
                  hard_cut = FALSE, verbose = FALSE)

# norm of coefficients
knitr::kable(model1$normed_betas)
}
